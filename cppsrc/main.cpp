//
//  main.cpp
//  274F16NearestSB
//
//  Created by Yunlong Liu on 12/9/16.
//  Copyright Â© 2016 Yunlong Liu. All rights reserved.
//

#include "BFEUCPtSolver.hpp"
#include "BFSBSolver.hpp"
#include "KDTSBSolver.hpp"
#include "BKDTSBSolver.hpp"
#include "GridSBSolver.hpp"
#include "BKDTGridSBSolver.hpp"
#include "UniLatLngBKDTGridSBSolver.hpp"
#include "UniCellBKDTGridSBSolver.hpp"
#include "UnionUniLatLngBKDTGridSBSolver.hpp"
#include "UnionUniCellBKDTGridSBSolver.hpp"



#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <sstream>
#include <iterator>
#include <algorithm>
#include <chrono>
#include <memory>
#include <typeinfo>
#include <random>
#include <regex>
#include <thread>
#include <cstdlib>
#include <map>


template <typename dist_type>
std::vector<Point<dist_type, 2>> generatetestSearchLatLngPts(size_t numTests, std::mt19937_64& mt) {
    std::uniform_real_distribution<dist_type> dist(0.0, 1.0);
    std::vector<Point<dist_type, 2>> testSearchLatLngPts;
    testSearchLatLngPts.reserve(numTests + 4);
    testSearchLatLngPts.insert(testSearchLatLngPts.end(),
                    {{Def::PI<dist_type>*0.5, Def::PI<dist_type>},
                     {-Def::PI<dist_type>*0.5, -Def::PI<dist_type>},
                     {-Def::PI<dist_type>*0.5, Def::PI<dist_type>},
                     {Def::PI<dist_type>*0.5, -Def::PI<dist_type>}});
    std::generate_n(std::back_inserter(testSearchLatLngPts), numTests, [&]()->Point<dist_type, 2> {
        return {-0.5*Def::PI<dist_type> + Def::PI<dist_type>*dist(mt),
                -Def::PI<dist_type> + 2.0*Def::PI<dist_type>*dist(mt)};});
    return testSearchLatLngPts;
}

template <typename dist_type>
void accuracyTestFromRefFile() {}


template <typename dist_type>
void accuracyTestFromRefSolver(const std::vector<Point<dist_type, 2>> &testSearchLatLngPts,
                               std::vector<const SBLoc<dist_type>*> &refLocs,
                               const SBSolver<dist_type>& testSolver,
                               const std::chrono::duration<dist_type> &duration) {
    dist_type testErrTotal = 0.0, refTotal = 0.0;
    size_t errorCount = 0;
    auto startTime = std::chrono::steady_clock::now();
    if (refLocs.empty()) {
        refLocs.reserve(1ull<<24);
        for (int locIdx = 0; locIdx < testSearchLatLngPts.size() && (std::chrono::steady_clock::now() - startTime < duration); ++locIdx) {
            refLocs.emplace_back(testSolver.findNearest(testSearchLatLngPts[locIdx]));
        }
        refLocs.shrink_to_fit();
        std::cout << "A total of " << refLocs.size() << " locations were generated by ref solver" << std::endl;
    } else {
        for (int locIdx = 0; locIdx < refLocs.size() && std::chrono::steady_clock::now() - startTime < duration; ++locIdx) {
            const SBLoc<dist_type>* testLoc = testSolver.findNearest(testSearchLatLngPts[locIdx]);
            dist_type testDist, refDist;
            auto testPt = testSearchLatLngPts[locIdx];
            auto refLoc = refLocs[locIdx];
            if (testLoc != refLoc
                && (std::fabs((testDist = testLoc->havDistComp(testPt)) - (refDist = refLoc->havDistComp(testPt))))
                > static_cast<dist_type>(0.000001)) {
                testErrTotal += testLoc->havDist(testPt);
                refTotal += refLoc->havDist(testPt);
                ++errorCount;
                auto[testLat, testLng] = testPt.dataArray();
                std::cout << "Test Point: Lat: " << SBLoc<dist_type>::toDegree(testLat)
                << ", Lng: " << SBLoc<dist_type>::toDegree(testLng) << std::endl
                << "Test result point: " << *testLoc << "Ref point: " << *refLoc << std::endl;
            }
        }
        std::cout << "A total test of " << refLocs.size() << " locations" << std::endl
                  << "Num of errors: " << errorCount << std::endl
                  << "Error percentage is: "
                  << errorCount*100.0/refLocs.size() << "%" << std::endl
                  << "Error in total hav dist diff is: " << std::fabs(testErrTotal - refTotal) << std::endl;
    }
}

template <typename dist_type>
void timeBuild(const std::shared_ptr<std::vector<SBLoc<dist_type>>> &locData,
               SBSolver<dist_type> &solver) {
    std::chrono::time_point<std::chrono::steady_clock> start = std::chrono::steady_clock::now();
    solver.build(locData);
    std::chrono::duration<dist_type> elapsedSeconds = std::chrono::steady_clock::now() - start;
    std::cout << std::regex_replace(typeid(solver).name(),
                                    std::regex("[A-Z]?[0-9]+|.$"), "")
              << std::endl << "Build time: " << elapsedSeconds.count() << std::endl;
    solver.printSolverInfo();
}

template <typename dist_type>
void timeNNSearch(const SBSolver<dist_type> &solver, std::vector<Point<dist_type, 2>> &testSearchLatLngPts,
                  unsigned int seed, std::chrono::duration<dist_type> secondsToTimeSearch) {
    std::mt19937_64 mt(seed);
    std::shuffle(testSearchLatLngPts.begin(), testSearchLatLngPts.end(), mt);
    std::vector<std::chrono::duration<dist_type, std::milli>> perSearchTimeVec;
    std::chrono::duration<dist_type, std::milli> totalElapsedTime, maxOneSearchTime{}, minOneSearchTime(std::numeric_limits<dist_type>::max());
    perSearchTimeVec.reserve(testSearchLatLngPts.size());
    std::chrono::time_point<std::chrono::steady_clock> startTime = std::chrono::steady_clock::now();
    for (int locIdx = 0;
         locIdx < testSearchLatLngPts.size() && (totalElapsedTime = std::chrono::steady_clock::now() - startTime) < secondsToTimeSearch;
         ++locIdx) {
        std::chrono::time_point<std::chrono::steady_clock> thisSearchStartTime = std::chrono::steady_clock::now();
        solver.findNearest(testSearchLatLngPts[locIdx]);
        perSearchTimeVec.emplace_back(std::chrono::steady_clock::now() - thisSearchStartTime);
    }
    
    std::for_each(perSearchTimeVec.cbegin(), perSearchTimeVec.cend(), [&](auto thisSearchDuration) mutable {
        maxOneSearchTime = std::max(maxOneSearchTime, thisSearchDuration);
        minOneSearchTime = std::min(minOneSearchTime, thisSearchDuration);
    });
    
    
    std::cout << std::endl << "Ave per Search Time: " << totalElapsedTime.count()/perSearchTimeVec.size()
              << " ms from " << perSearchTimeVec.size() << " searches" << std::endl
              << "Max sinlge search time: " << maxOneSearchTime.count() << std::endl
              << "Min single search time: " << minOneSearchTime.count() << std::endl << std::endl;
    
}

template <typename dist_type>
void writeResults(const char* argv[],
                  const std::vector<Point<dist_type, 2>> &testSearchLatLngPts,
                  const SBSolver<dist_type> *solver) {
    std::ofstream outrefLocPtrPerSearchTimePairVecs(argv[2], std::ios::app);
    std::transform(testSearchLatLngPts.cbegin(), testSearchLatLngPts.cend(),
                   std::ostream_iterator<std::string>(outrefLocPtrPerSearchTimePairVecs),
                   [&](const auto &p){
                       const auto resultLoc = solver->findNearest(p);
                       return std::to_string(p[0]) + " " + std::to_string(p[1]) + " " +
                       std::to_string(resultLoc->geoPt[0]) + " " + std::to_string(resultLoc->geoPt[1]) +
                       resultLoc->city + "," + resultLoc->addr + std::endl;});
    outrefLocPtrPerSearchTimePairVecs.close();
}


template <typename dist_type>
void mainContent(int argc, const char * argv[]) {
    
    std::ifstream infileLocs(argv[1]);
    dist_type aveActualLocsPerCell = argc < 4 ? Def::DEFAULT_AVE_ACTUAL_LOCS_PER_CELL : std::stod(argv[3]);
    std::size_t maxCacheCellVecSize = argc < 5 ? Def::DEFAULT_MAX_CACHE_CELL_VEC_SIZE : std::stoi(argv[4]);
    bool testAccuracy = argc < 6 ? Def::DEFAULT_TEST_ACCURACY : std::tolower(argv[5][0]) == 'y';
    std::chrono::duration<dist_type> secondsToTimeAccuracyTest(Def::DEFAULT_TEST_ACCURACY_DURATION_IN_SECONDS);
    if (testAccuracy) {
        try {
            secondsToTimeAccuracyTest = std::chrono::duration<dist_type>(std::stoi(std::regex_replace(argv[5], std::regex("[^0-9]*([0-9]+).*"), std::string("$1"))));
        }   catch (std::invalid_argument e) {}
    }
    std::chrono::duration<dist_type> secondsToTimeSearch(Def::DEFAULT_TIME_SEARCH_DURATION_IN_SECONDS);
    if (argc >= 7) {
        try {
            secondsToTimeAccuracyTest = std::chrono::duration<dist_type>(std::stoi(std::regex_replace(argv[6],  std::regex("[^0-9]*([0-9]+).*"), std::string("$1"))));
        } catch (std::invalid_argument e) {}
    }
    std::ifstream inRefLatLngPtLocPairVec(argv[7]);
    std::ofstream outRefLatLngPtLocPairVec(argv[8]);
    
    
    std::random_device rd;
    std::seed_seq seq{rd(), rd(), rd(), rd(), rd(), rd(), rd(), rd()};
    std::mt19937_64 mt(seq);
    //mt.seed(686868);

    
    testAccuracy = true;
    //maxCacheCellVecSize = (1 << 16ull);
    //maxCacheCellVecSize = (1 << 9ull);
    aveActualLocsPerCell = 0.4;
    
    auto locData = std::make_shared<std::vector<SBLoc<dist_type>>>();
    locData->reserve(1 << 24);
    locData->assign(std::istream_iterator<SBLoc<dist_type>>(infileLocs),
                    std::istream_iterator<SBLoc<dist_type>>());
    infileLocs.close();
    locData->shrink_to_fit();
    std::shuffle(locData->begin(), locData->end(), mt);
    
    /*
    if (numOfLocsToWriteToFile) {
        auto solver = std::make_unique<BFSBSolver<dist_type>>();
        //auto solver = std::make_unique<BKDTSBSolver<dist_type><KDTree>>();
        timeBuild<dist_type>(locData, *solver);
        writeResults<dist_type>(argv, generatetestSearchLatLngPts<dist_type>(numOfLocsToWriteToFile, mt), solver.get());
        return 0;
    } */
    

    std::unique_ptr<SBSolver<dist_type>> solvers[] = {
        //std::make_unique<BFSBSolver<dist_type>>(),
        //std::make_unique<BFEUCPtSBSolver<dist_type>>(),
        //std::make_unique<KDTSBSolver<KDTree,dist_type>>(),
        //std::make_unique<BKDTSBSolver<KDTree, dist_type>>(),
        //std::make_unique<BKDTSBSolver<dist_type><KDTreeCusMem>>(),
        //std::make_unique<BKDTSBSolver<KDTreeExpandLongest, dist_type>>(),
        std::make_unique<BKDTSBSolver<KDTreeExpandLongestVec, dist_type>>(),
        //std::make_unique<GridSBSolver<dist_type>>(),
        //std::make_unique<BKDTGridSBSolver<dist_type>>(aveLocPerCell),
        //std::make_unique<UniLatLngBKDTGridSBSolver<KDTree, dist_type>>(0.85*aveLocPerCell, MAX_CACHE_CELL_VEC_SIZE),
        //std::make_unique<UniLatLngBKDTGridSBSolver<KDTreeCusMem, dist_type>>(0.85*aveLocPerCell, MAX_CACHE_CELL_VEC_SIZE),
        //std::make_unique<UniLatLngBKDTGridSBSolver<KDTreeExpandLongest, dist_type>>(0.85*aveLocPerCell, MAX_CACHE_CELL_VEC_SIZE),
        //std::make_unique<UniLatLngBKDTGridSBSolver<KDTreeExpandLongestVec,dist_type>>(aveLocPerCell, MAX_CACHE_CELL_VEC_SIZE),
        //std::make_unique<UnionUniLatLngBKDTGridSBSolver<dist_type><KDTreeExpandLongestVec>>(aveLocPerCell, MAX_CACHE_CELL_VEC_SIZE),
        //std::make_unique<UniCellBKDTGridSBSolver<dist_type><KDTree>>(aveLocPerCell, maxCacheCellVecSize),
        // std::make_unique<UniCellBKDTGridSBSolver<dist_type><KDTreeCusMem>>(aveLocPerCell, maxCacheCellVecSize),
        //std::make_unique<UniCellBKDTGridSBSolver<KDTreeExpandLongest, dist_type>>(aveLocPerCell, MAX_CACHE_CELL_VEC_SIZE),
        //std::make_unique<UniCellBKDTGridSBSolver<KDTreeExpandLongestVec, dist_type>>(aveLocPerCell, MAX_CACHE_CELL_VEC_SIZE),
        std::make_unique<UnionUniLatLngBKDTGridSBSolver<KDTreeExpandLongestVec, dist_type, Def::Threading_Policy::SINGLE>>(aveActualLocsPerCell, maxCacheCellVecSize),
        std::make_unique<UnionUniCellBKDTGridSBSolver<KDTreeExpandLongestVec, dist_type, Def::Threading_Policy::SINGLE>>(aveActualLocsPerCell, maxCacheCellVecSize),
        std::make_unique<UnionUniLatLngBKDTGridSBSolver<KDTreeExpandLongestVec, dist_type, Def::Threading_Policy::MULTI_OMP>>(aveActualLocsPerCell, maxCacheCellVecSize),
        std::make_unique<UnionUniCellBKDTGridSBSolver<KDTreeExpandLongestVec, dist_type, Def::Threading_Policy::MULTI_OMP>>(aveActualLocsPerCell, maxCacheCellVecSize),
    };
    
    unsigned int timeNNSeed = rd();
    std::vector<Point<dist_type, 2>> testSearchLatLngPts = generatetestSearchLatLngPts<dist_type>(Def::MAX_SEARCH_LOCS, mt);
    std::vector<const SBLoc<dist_type>*> refLocs;
    std::vector<Point<dist_type, 2>> testAccuracyLatLngPts;
    if (testAccuracy)
        testAccuracyLatLngPts = generatetestSearchLatLngPts<dist_type>(Def::MAX_SEARCH_LOCS, mt);

    for (size_t i = 0; i < std::size(solvers); ++i) {
        using namespace std::chrono_literals;
        std::this_thread::sleep_for(100ms);
        timeBuild(locData, *solvers[i]);
        std::this_thread::sleep_for(100ms);
        timeNNSearch(*solvers[i], testSearchLatLngPts, timeNNSeed, secondsToTimeSearch);
        if (testAccuracy) {
            accuracyTestFromRefSolver(testAccuracyLatLngPts, refLocs, *solvers[i], secondsToTimeAccuracyTest);
        }
        solvers[i].reset();
        std::cout << std::endl;
    }
    
}

int main(int argc, const char * argv[]) {
    if (argc >= 2 && std::strcmp(argv[2], "float")){
        mainContent<float>(argc, argv);
    } else {
        mainContent<Def::DEFAULT_DIST_TYPE>(argc, argv);
    }
    return 0;
}

 
 
 
 
 
